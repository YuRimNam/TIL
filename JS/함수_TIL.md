# Javascript 함수
함수란 일련한 명령어들을 집합해놓은 하나의 묶음이다. 하나의 작업이 계속해서 반복될 경우, 함수라는 개념으로 명령어들을 묶어 재사용 할 수 있다.<br>계산기 프로그램이 있다고 가정해보자. 그렇다면 그 계산기에서는 덧셈 연산을 무수히 많이 실시할 것이다. **매번 덧셈 연산을 실시할 때마다 연산 코드를 매번 작성할 수 없으므로, 계산기 입장에서는 하나의 코드를 미리 작성해놓고 그 코드를 수시로 불러오는 것이 훨씬 효율적이다.** <br> 이처럼 하나의 작업을 묶는 것을 함수라고 한다.

## 함수 선언문
함수를 정의하는 방법에는 총 3가지의 방법이 있다. **함수 선언문을 사용**하는 것과, **함수 표현식을 사용**하는 것, 마지막으로 **funtion() 생성자를 사용**하는 것이다. <br>
이 부분에서는 함수 선언문으로 함수를 정의하는 방법을 알아보겠다. <br>

JS에서는 함수를 정의할 때 사용되는 특정한 구문이 있다. 바로 funtion() 문이다. 기본적인 사용 형태는 아래와 같다.

> ~~~
> funtion plus(a, b) {
>   let c=0;
>   a+b=c;
>   return c;
> }

위의 코드에서 `plus` 는 함수의 이름, `a, b` 는 함수에게 전달되는 인수의 이름, `let c; ~ return c;` 까지는 함수의 몸통을 구성하는 문이라고 볼 수 있다.

## 함수 표현식
JS에서 함수는 **객체**이므로 함수 리터럴 방식으로 정의하고 변수에 할당을 할 수 있다. 이것을 바로 **함수 표현식**이라고 한다. <br>

위에서 만들었던 plus() 함수를 표현식으로 나타내면 아래와 같다.

> ~~~
> var add=function plus(a, b) {
>               let c=0;
>               a+b=c;
>               return c;  
>         } 

함수 표현식으로 함수를 선언하면 함수명을 생략할 수 있는데, 이를 **익명 함수**라고 한다. 위의 예시는 함수명을 생략하지 않은 **기명 함수** 이다. <br>
함수 표현식으로 기명 함수를 선언할 경우, 함수명이 아닌 변수명으로 함수를 호출해야 한다. 만일 함수명으로 호출한다면 에러가 발생한다.

## 함수 선언문과 함수 표현식의 차이
한 마디로 정리하자면, **함수 선언문은 호이스팅에 영향을 받지만 함수 표현식은 호이스팅에 영향을 받지 않는다.**
아래 예시를 살펴보자.

~~~
    string(); //sinabro
   
    function string() {
        return 'sinabro';
    };

    Number(1,2); //에러 발생

    var Number= function(a,b) {
        return a + b;
    };
~~~

예시와 같이 함수 선언문은 호이스팅에 영향을 받고, 함수 표현식은 받지 않는다는 사실을 알 수 있다. 이는 **함수 표현식은 '식' 이기에 하나의 값이 있기 때문이지만, 함수 선언문은 '문' 이기에 파싱 후 남는 값이 없기 때문**이다.

## 함수의 접근 범위

> ~~~
> var x='hello';
>
> function ch() {
>    var x='me';
>    x='It\'s me';
> };
>
> ch();
> console.log(x); //hello
> ~~~

> ~~~
> var x='hello';
> 
> function ch() {
>   x='It\'s me';
> };
>
> ch();
> console.log(x); //It's me
> ~~~

두 코드의 차이점은 무엇일까? 첫 번째 코드에서는 함수 내부에서의 x 가 전역변수의 x 에 영향을 끼치지 않았지만 두 번째 코드에서의 x 는 전역변수의 x 에 영향을 끼쳤다. 왜 그런 것일까? <br>
그 이유는 **ch 함수 내부의 함수 선언**과 관련이 있다. <br> 
첫 번째 코드에서 변경된 x는 ch 함수 내부에 선언된 **지역변수 x** 에 영향을 끼쳤기 때문에 `hello` 가 출력된 것이며, 투 번째 코드에서 변경된 x는 ch 함수 내부에 선언된 지역변수가 없었기 때문에 전역변수 x에 영향을 끼쳐 `It's me` 가 출력된 것이다.
즉, **내부 함수에서는 외부 함수의 변수에 접근 가능하지만 외부 함수에서는 내부 함수의 변수에 접근할 수 없다.**
이처럼 계속 범위를 넓히며 찾는 관계를 **스코프 체인**이라고 한다.

## 콜스택(실행 컨텍스트)이란?
`실행 컨텍스트? == 실행 가능한 코드의 실행 환경` 이라고 이해할 수 있다. 여기서 말한 실행 가능한 코드는 전역 코드, Eval 코드, 함수 코드이다. <br>

필자가 이해한 컨텍스트는 한 코드가 실행될 때마다 생성되는 **그 코드의 흐름을 관리하는 스택** 이다. 실행 컨텍스트는 앞서 말했듯 코드가 실행될 때 생성되고, 코드가 끝날 때 종료된다. 컨텍스트는 네 가지의 원칙을 가진다. <br>
첫째, **전역 컨텍스트 하나가 생성**된 후, **함수 호출 시마다 컨텍스트가 생성**된다. <br>
둘째, 컨텍스트 생성 시 컨텍스트 안에 `변수객체(arguments, variable), scope chain, this` 가 생성된다. <br>
셋째, 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾는다. <br>
넷째, 함수 실행이 마무리되면 해당 컨텍스트는 사라지며 함수 컨텍스트는 함수가 종료되면 사라진다. <br>