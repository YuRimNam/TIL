# 객체
JS는 객체 지향의 스크립트 언어이다. 즉, 자바 스크립트는 거의 모든 부분이 객체로 이루어져 있으며 기본 자료형을 제외한 모든 값들은 모두 객체이다. <br>
여기서 객체란 **프로퍼티들의 모임**이라고 할 수 있으며, 프로퍼티들은 **키(key)** 값과 **값(value)** 의 연결로 이루어져 있다. 프로퍼티가 함수인 경우를 **메소드**라고 부른다.


## 객체의 생성 방식
객체를 생성하는 방식은 총 4가지가 있다. 첫 번째는 `객체 이니셜라이저(객체 리터럴) 방식`을 사용하는 것이고, 두 번째 방식은 `Object.create` 메서드 사용하는 것이다. 세 번째 방식은 `new` 생성자와 `Object()` 생성자 방식을 사용하는 것이며 마지막은 `생성자 함수를 사용`하는 것이다. <br>
이 부분에서는 이니셜라이저 방식과 `new, Object()` 생성자 사용 방식, 메서드 사용 방법을 알아보겠다. 생성자 방식은 다음 부분에서 집중적으로 설명한다. <br>

### 객체 이니셜라이저 방식
가장 흔한 방식이자 익숙한 방식이다. 객체 리터럴이라고도 불리는 이 방식은 중괄호 `({…})` 를 사용해 객체를 생성하는 방식이다. 만일 이니셜라이저 방식을 사용하여 객체를 만들 때, `{}` 내에 아무것도 기술하지 않으면 빈 객체가 만들어지며 `{}` 안에 **1개 이상의 프로퍼티와 프로퍼티의 값을 기술하면 기술한 프로퍼티가 추가된 객체**를 만들 수 있다.

~~~
let obj = { a:1,
            5:3,
            "hello": 5 };

console.log(obj.hello)  // 5
console.log(obj.a)  // 1
console.log(obj.5)  // missing ) after argument list
console.log(obj[5]) //3 
~~~

다음은 이니셜라이저 방식으로 객체 obj를 생성한 모습이다. `obj`는 객체의 이름, `a, 5, "hello"`는 **프로퍼티 이름**, `1, 3, 5`는 **프로퍼티의 값**이다. 프로퍼티의 이름에 들어가는 값은 JS에서 문자열로 변환시켜준다. 

### new, Object() 생성자
여기서 의문이 드는 사람이 있을 것이다. `생성자 함수` 와 `new, Object() 생성자`를 구분하였기 때문이다. 같은 생성자이기 때문에 같은 것이 아닌가? 하는 생각이 들 수도 있겠지만, `생성자 함수`와 `new, Object() 생성자`로 객체를 생성하는건 엄격한 차이가 있다. 이 둘의 차이점은 생성자 함수 부분에서 기술하도록 하겠다. <br>

객체 이니셜라이저 방식으로 객체를 생성할 때에 프로퍼티와 같이 생성할 수 있는 것을 우리는 방금 확인할 수 있었다. 또한 이니셜라이저 방식은 빈 객체를 만드는 것또한 가능했다. 이 `new, Object() 생성자`로 객체를 만드는 방식으로는 **생성과 동시에 프로퍼티를 추가할 수 없다.** <br>
한마디로 말하자면, **빈 객체를 생성한 후에 프로퍼티를 추가하는 방법**이 `new, Object() 생성자` 방식이다.

~~~
let card = new Object();

card.number = 10;
card.color = "red";
card.pattern = "heart";

console.log("this card number is " + card.number + ", color is " + card.color + ", parrtern is " + card.pattern) 
// this card number is 10, color is red, parrtern is heart
~~~

위의 코드는 `new, Object() 생성자`를 이용해 객체를 생성한 간단한 예시이다. 앞에서 설명한 것처럼 `new Object();` 에서 빈 객체를 생성하고 다음 코드 부분에서 프로퍼티를 추가하는 모습을 볼 수 있다. <br>
물론 모든 객체를 `new, Object()` 연산자로 생성해야 하는 것은 아니다. 오히려 이니셜라이저 방식으로 선언하는 것이 더 편하다. <br>
하지만, **이니셜라이저 방식**으로 선언하는 것 역시 `Object()` 생성자가 내장되어 있기 때문에 **이니셜라이저 방식**으로 선언하는 것은 `new, Obejct()` 방식으로 선언하는 것과 같다. 


### Object.create 메서드 사용
이 메서드는 **사용할 프로토타입 객체를 사용자가 직접 선택할 수 있기 때문에 유용**한 메서드이다. 객체 생성 시, 생성자 함수가 없어도 생성이 가능한 유일한 방법이다. 아래는 사용 방식이다.

> ~~~
> Object.create(proto [, propertiesObject])
> ~~~

`proto` 는 새로 만든 객체의 프로토타입이 될 객체이다. 이 부분으로 프로토타입의 객체를 선택할 수 있다. `propertiesObject` 는 속성 객체라는 뜻으로, 프로토타입 객체에 이 인자의 속성을 추가적으로 가지게 된다.

## 생성자 함수
생성자 함수는 위에서 설명했던 객체를 생성하는 방식과는 차이점이 있다. <br> 가령, 네모 고등학교 1학년 2반 학생 한 명 한 명의 객체를 만들어야 하는 상황이 왔다고 가정했을 때, 1학년 2반 학생들은 모두 1학년이고 2반이며 네모 고등학교에 재학중이고 17살이라는 공통점을 가지고 있다. <br>위의 생성 방식으로 객체를 생성한다면 학생 한 명 한 명 마다 같은 프로퍼티가 중복해서 여러번 들어간다. 이렇게 된다면 코드의 효율성이 크게 떨어진다. <br>
생성자 함수도 함수이기 때문에, 우리가 알고 있는 함수와 비슷한 장점을 가진다. 바로 여러번 쓰이는 작업을 하나로 묶어 가져다 사용한다는 장점이다. 생성자 함수를 사용하면 **마치 객체를 생성하기 위한 템플릿처럼 사용하여 구성이 동일한 객체 여러 개를 간편하게 생성할 수 있다.** 붕어빵 틀에 붕어빵을 만드는 것과 같은 원리이다.

~~~
function Class(number, name, age) {
    classnumber = 2;
    this.number = number;
    this.name = name;
    this.age = age;
}

let Person1 = new Class(12, "움뇸뇸", 17);

Person1 // Class {number: 12, name: "움뇸뇸", age: 17}
~~~

생성자 함수의 이름은 일반적으로 대문자로 시작한다. 이는 생성자 함수임을 인식시키는데에 도움을 준다. 또한 프로퍼티나 메소드 앞에 기술한 `this`는 생성자 함수가 생성할 **인스턴스**를 가리킨다. `this`에 바인딩되어 있는 프로퍼티나 메소드는 외부에서 참조가 가능, 즉 `public` 속성을 가지며 생성자 함수 내에서 선언된 일반 변수는 외부에서 참조가 불가능, 즉 `private`속성을 가지게 된다.  <br>
위의 설명에서 필자가 생성자 함수도 함수라는 말을 기재해놨을 것이다. **생성자 함수는 객체를 만드는 전용 함수가 아니라 함수에 new 생성자를 붙이고 호출하여 객체를 만드는 함수**이다. 즉, 일반 함수도 **new 생성자를 사용하면 생성자 함수처럼 동작할 수 있다**는 것이다. 생성자 함수라고 해서 따로 문법이 정해져 있는 것은 아니다.  

## 프로퍼티
쉽게말해 프로퍼티란, **객체 안에 속한 변수**와도 같다. 프로퍼티는 미리 정의된 객체 타입에 속성을 추가한다. <br>
프로퍼티의 이름은 기본적으로 문자열로 작성한다. 숫자로도 작성이 가능한데, 이는 JS가 암묵적으로 형변환 되어 문자열이 된다. 프로퍼티의 이름은 문자열이므로 따옴표`('', "")`를 사용하는데, 자바 스크립트에서 사용 가능한 유효한 이름인 경우 따옴표를 생략할 수 있다. 단, 이에 해당하지 않는 경우 따옴표를 필수적으로 붙여야 한다. <br>
가장 처음에 기술했듯 프로퍼티는 **키(key)** 값과 **값(value)** 의 연결로 이루어져 있다. 프로퍼티가 함수인 경우는 **메소드**라고 한다. 

### 프로퍼티 다루기

1. 프로퍼티 값 읽기
    * 프로퍼티를 읽는 방식으로는 마침표 `.`표기법과 대괄호 `[]`표기법이 있다. 겉보기에 마침표 표기법과 대괄호 표기법은 큰 차이가 없어 보이지만, 꼭 알아야 하는 차이점이 하나 있다.
    * 위에서 사용 가능한 유효한 이름은 따옴표를 사용하지 않아도 된다고 설명했다. 프로퍼티의 값을 읽을 때에도 이것이 똑같이 적용된다. 사용 가능한 유효한 이름을 읽을 땐 마침표, 대괄호 모두 사용이 가능하지만 아닌 경우에는 무조건 대괄호 표기법으로 읽어야 한다.
    * 대괄호 표기법을 사용하는 경우, **대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열**이어야 한다.
    * 객체에 존재하지 않는 프로퍼티를 참조하면 `undefined`를 반환한다.
<br>
2. 프로퍼티 값 갱신
    * 객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티의 값은 갱신된다.
> ~~~
> let obj = { a:1, b:8 };
> obj.b // 8
> obj.b = 2;
> obj.b // 2
> ~~~ 
3. 프로퍼티 동적 생성
    * 객체가 소유하지 않은 프로퍼티에 값을 할당하면 해당 프로퍼티 객체에 추가하고 값을 할당한다.
> ~~~
> obj.c = 10;
> obj.c // 10
> obj // {a:1, b:2, c:10}
> ~~~

1. 프로퍼티 삭제
   * `delete` 연산자를 사용하면 프로퍼티를 사용할 수 있다.
> ~~~
> delete obj.c
> obj // {a:1, b:2}
> ~~~
5. 프로퍼티 나열하기
    1. for...in 루프
        * 프로퍼티의 값`(value)`을 나열한다.
    2. Object.keys()
        * 프로퍼티의 키`(key)`값을 나열한다.
    3. Object.getOwnProeprtyName()
        * 프로퍼티의 이름을 반환한다.
   

## pass-by-value VS pass-by-reference
`pass-by-value` 방식과 `pass-by-reference` 방식은 전혀 어려워 할 것이 없다. 두 방식 모두 쉽게 말하자면 값을 복사하는 방식이다. 값을 어떻게 복사하느냐에 따라서 `pass-by-value`와 `pass-by-reference`로 나뉜다.


### pass-by-value
`pass-by-value` 방식은 기본 자료형이 값을 전달하는 방식이다. 이 말은 즉 값을 복사하여 전달한다고도 할 수 있다. 기본 자료형은 값이 한 번 정해지면 변경할 수 없다. 또한 이 값들은 **변수 할당 시점**에 메모리의 **스택 영역**에 고정된 **메모리 영역을 점유하고 저장**한다. 

> ~~~
> let a = 1;
> let b = a;
>
> console.log(a, b); // 1, 1
> b = 20;
> console.log(a, b); // 1, 20
> ~~~

위의 코드를 확인하면 알 수 있듯 b에 a를 대입했는데도 불구하고 **b의 바뀐 값이 a에 적용되지 않는다**라는 것을 알 수 있다. 이를 통하여 우리는 `pass-by-value` 방식이 **참조값을 전달하는 것이 아닌 값 자체를 전달하는 것**을 알 수 있다. 이를 **깊은 복사** 라고 한다.

### pass-by-reference
`pass-by-reference` 방식은 참조값을 전달하는 방식이다. `object type`을 객체형 혹은 참조형이라고 하는데, 여기서 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리되는 것을 참조형이라고 한다. <br> 위에서 설명했듯 **기본 자료형은 값이 한 번 정해지면 바꿀 수 없지만, 객체는 프로퍼티를 변경, 추가, 삭제가 가능한 변경 가능한 값**이다. 그렇기 때문에 어느정도 사용되는지, 메모리는 어느정도 확보해야 하는지 알 수 없기 때문에 **힙 영역**에 저장된다.

> ~~~
> let obj = {
>       a: 1
>   };
> let foo = obj;
> 
> console.log(obj.a, foo.a); // 1, 1
> 
> foo.a = 20;
> 
> console.log(obj.a, foo.a); // 20, 20
> ~~~

위는 `pass-by-refernce`의 간단한 예제이다. `pass-by-value`때와는 다르게 `foo`객체의 값만 바꿨을 뿐인데 그 변동 결과가 `obj`에도 적용이 되는걸 확인할 수 있다. 이는 `pass-by-value`와는 다르게 값이 아닌 참조값을 저장하고 있기 때문이다. 즉, `obj`와 `foo`모두 동일한 객체를 가리키고 있으므로 값이 동시에 변동되는 것이라고 할 수 있다. **객체는 참조 방식으로 값을 전달하며, 결코 복사되지 않는다.**

## 객체의 종류
JS에서 객체의 종류는 다양하게 나뉘어져 있다. 이는 JS의 대부분이 객체로 이루어져 있기 때문이다. 내장 객체와 사용자 정의 객체, 네이티브 객체 등 객체의 종류는 다양하다. 이 부분에서는 JS의 객체의 종류를 소개하기로 하겠다.

### Built-in Object
`Built-in Object`는 말 그대로 내장 객체를 뜻한다. JS를 처음 시작할 때 자동으로 생성되어 있는 `Window`객체가 이에 포함된다. Built-in-Object는 Standard Built-in Objects, Native Object로 나뉜다.

#### Standard Built-in Objects
`Standard Built-in Objects`는 표준 내장 객체를 뜻하며, **전역 스코프 내 객체들**을 의미한다. 

#### Native Object
`Native Object`는  ECMAScript 명세에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공하며, 애플리케이션의 환경과 관계없이 언제나 사용할 수 있다. 종류는 `BOM`과 `DOM`으로 나뉜다.

1. BOM
   * BOM은 Browser Object Model의 약자로, JS와 브라우저가 소통하게 해주는 모델이다.
   * 모든 브라우저의 대부분이 JS와의 상호작용에 있어 비슷한 메소드와 속성으로 동작하기 때문에 이와 같은 메소드들을 BOM이라 칭한다.
   * 이는 JS에서 웹 브라우저를 관리할 목적으로 제공되는 객체 모음을 대상으로 하는 모델이다.
   * 간단히 설명하자면, 웹 브라우저의 창이나 프레임을 추상화 해 프로그래밍적으로 제어할 수 있도록 제공하는 수단이다.

2. DOM
   * DOM은 Document Object Model의 약자로, 웹 페이지의 구조 및 스타일, 내용 등을 변경할 수 있게 해주는 모델이다.
   * BOM이 제어할 수 있도록 제공해주는 수단이라면, DOM은 BOM에서 제어할 수 있도록 JS와 웹 페이지를 연결해주는 수단이다.
   * 웹 페이지의 객체 지향 표현이라고도 할 수 있다.

### Host Object
`Host Object`는 이름만 보면 짐작할 수 있듯 사용자가 정의한 객체를 뜻한다. 그렇기 때문에 Built-in object와 Native Object가 구성되고 난 이후에 구성된다. 