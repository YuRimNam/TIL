# 표현식과 연산자
연산자는 우리가 걱정하는 것보다 훨씬 더 쉬운 개념이다. JS에서 사용되는 연산자라고 해서 더 어렵거나 복잡하지 않다. 이 글에서는 JS에서 사용되는 연산자의 개념을 하나하나 알아보도록 하겠다. 

## 대입 연산자
**대입 연산자**는 오른쪽 피연산자의 값을 왼쪽 피연산자에 대입하는 연산자이다. 가장 대표적인 예시로는 `등호(=)` 가 있다. <br>
등호의 간단한 예시로는 `x = y`가 있다. 이는 `y` 의 값을 `x` 에 넣겠다는 뜻이다. <br>
이 외에 복합 대입 연산자가 있다. 복합 대입 연산자는 **연산의 약칭**이다. 다음은 복합 대입 연산자의 간단한 예시다.

> ~~~
> x += y //x = x + y
> x |= y //x = x | y
> x *= y //x = x * y
> ~~~

위의 예시처럼 연산을 줄여 표현할 수 있다. 이는 **덧셈, 뺄셈, 나눗셈, 곱셈, 모듈러, 왼쪽 이동, 오른쪽 이동, 부호 없는 오른쪽 이동, 논리곱, 배타적 논리합, 논리합** 에 적용될 수 있다.

## 구조 해제
필자가 이해한 구조 객체는 배열 혹은 객체에서 데이터를 추출해 각각의 변수에 할당하는 것을 말한다. 아래의 예시를 살펴보자.

> ~~~
> let foo = [ "hello", "my", "name" ];
> let [hi, you, your] = foo;
> console.log(hi); //hello
> ~~~

아래 예시는 배열 `foo`의 인덱스 하나하나에 이름을 지정해 준 것이라고 보면 이해가 쉽다. 0번 인덱스에는 `hello` 가, 1번 인덱스에는 `my` 가, 2번 인덱스에는 `name` 이 들어가있고 각각의 인덱스에게 이름을 지정해 준 것이다. 그렇기 때문에 `hi` 를 출력하면 `hi` 이름을 가진 0번 인덱스의 값 `hello` 가 출력된다. <br>
또한 이 특성을 이용해 **선언에서 분리한 할당, 변수 값 교환하기, 함수에서 반환된 배열 파싱, 일부 반환값 무시하기** 등을 할 수 있다. <br>
이는 배열 뿐만이 아니라 객체에서도 포함되는 내용이다.

## 비교 연산자
비교 연산자는 말 그대로 비교를 해주는 연산자이다. 비교한 값에 따라 불리언 값을 반환하고, 주로 조건문에 사용된다. 아래는 비교 연산자의 종류이다.

> ~~~
> x == y //x와 y가 같으면 true 반환
> x != y //x와 y가 다르면 true 반환
> x === y //x와 y가 타입까지 같으면 true 반환
> x !== y //x와 y의 타입이 다르면 true 반환
> x > y //x가 y보다 크면 true 반환
> x >= y //x가 y보다 크거나 같으면 true 반환
> x < y //x가 y보다 작으면 true 반환
> x <= y //x가 y보다 작거나 같으면 true 반환

> 단, `(=>) 는 연산자로 판단되지 않고 화살표 함수를 나타내는 기호`이기 때문에 주의해야 한다.

## 산술 연산자
산술 연산자는 피연산자로 숫자값을 가진다. 기본적인 산술 연산자로는 덧셈`(+)`, 뺄셈,`(-)` 곱셈`(*)`, 나눗셈`(/)`이 있다. 우리가 흔히 사용하는 연산과 같으며, 타 언어들이 부동 소수점을 연산하는 것처럼 동작한다. <br>
단, **나눗셈 연산을 할 때 0 으로 나누면 `Infinity`가 발생한다.**
<br>
JS는 위에 설명한 네 연산자 말고도 아래에서 설명하는 산술 연산자를 제공한다. 

| 연산자 | 설명 | 예시 |
|:--------:|:--------:|:--------:|
| 나머지 연산자(`%`) | 이항 연산자이며, 두 피연산자를 나눈 후 나머지를 반환 | `10%3 //1` |
| 증감 연산자(`++`) | 단항 연산자이며, 피연산자에 1을 더한다. | `x`가 1일 때 `++x` 는 2반환, `x++`는 1반환 |
| 감소 연산자(`--`) | 단항 연산자이며, 피연산자에서 1을 뺀다. | `x`가 2일 때 `--x`는 1반환, `x--`는 2 반환 |
| 단항 부정 연산자(`-`) | 단항 연산자이며, 피연산자의 반댓값을 반환한다. | `x`가 3일 때 `-x`는 -3 |
| 숫자화 연산자(`+`) | 단항 연산자이며, 피연산자가 숫자값이 아니라면 피연산자를 숫자로 변환시킨다. | `+"3" //3` `+true //1` |

## 비트 연산자
비트 연산자는 피연산자를 10, 16, 8진수로 판단하지 않고 32비트의 집합으로 취급한다. 예를 들어, 9는 `1001`로 연산이 된다. <br>
비트 연산자의 종류에는 다음이 있다.

> ~~~
> a & b
> a | b
> a ^ b
> ~a;
> a << b
> a >> b
> a >>> b

## 논리 연산자
논리 연산자는 보통 부울 값(`true, false`)을 사용한다. 부울 값들이 사용될 때, 연산자는 부울값을 반환한다. 그러나 `&& 과 ||` 연산자는 실제로 명시된 값들 중 하나를 반환한다.
<br>
논리 연산자에는 `&&(논리 곱), ||(논리 합), !(논리 부정)` 가 있다.
<br>
논리 연산자에서는 우리가 알아야 할 한 가지의 중요한 법칙이 있다. 바로 **단축 계산** 이다. 논리 연산자가 왼쪽에서 오른쪽으로 평가될 때, 단축 계산의 법칙에 따라 다음과 같은 값들이 반환된다. <br>

> ~~~
> false && anything //false
> true || anything //true
> ~~~

위의 논리곱 코드는 첫 번째 피연산자가 false이기 때문에 뒤의 연산을 실행하지 않고 false 값을 반환한다. <br>
논리합 코드도 마찬가지다. 첫 번째 피연산자가 true이기 때문에 뒤의 연산을 실행하지 않고 true로 값을 반환한다. <br>
아래는 논리 연산자의 다른 연산 동작을 설명한 코드이다.

> ~~~
> false && true //false
> true || false //true
> ~~~

위의 코드를 설명하자면 간단하다.<br> 논리곱(`&&`)연산은 첫 번째 피연산자가 `false`이기 때문에 뒤의 값에 상관없이 `false`가 반환되는 것이다. 만일 첫 번째 피연산자가 `true` 이면, 두 번째 피연산자로 반환값이 달라진다. <br> 논리합(`||`)연산은 첫 번째 피연산자가 `true` 이기 때문에 뒤의 값에 상관없이 `true`가 반환된다. 만일 첫 번째 피연산자가 `false` 이면, 두 번째 피연산자로 반환값이 달라진다.  

## 조건 연산자
조건 연산자는 우리가 흔히 아는 삼항 연산자(`조건 ? 값1 : 값2`)이다. 이는 조건에 따라 둘 중 하나의 값을 가질 수 있다.<br>
**만일 조건식이 참이라면 값1 을 반환하고, 거짓이라면 값2 를 반환한다.** 조건 연산자는 표준 연산자를 사용하는 어디든 조건 연산자를 사용할 수 있다.

## 단항 연산자
단항 연산자는 이름 그대로 오직 하나의 피연산자만을 가지고 연산을 한다. 종류는 `delete`와 `typeof`, `void`가 있다.
<br>
`delete` 연산자는 객체, 객체의 속성, 배열의 특정한 위치에 있는 객체를 삭제시킨다. 다음은 delete의 문법이다.

~~~
delete object;
delete object.property;
delete object[index];
~~~

`object`는 객체의 이름이며 `property`는 객체의 속성, `index`는 배열의 위치를 나타내는 정수이다. <br>
만일 `delete` 연산이 성공했다면 속성이나 원소를 `undefined`로 설정하며, 연산이 수행 가능할 땐 `true`를 반환하고 가능하지 않을 땐 `false`가 반환된다. <br>
단, 배열의 원소를 삭제할 때에는 배열의 길이에 영향을 주지는 못하며 그 자리에 `undefined`가 들어가게 된다. <br>

`typeof` 연산자는 피연산자의 타입을 나타내는 문자열을 반환한다. typeof 연산자가 반환하는 값은 총 5가지이다. `function, string, number, object, undefined`. <br>
또한 `true`와 `null`에 대해서는 다음과 같이 반환한다. 

> ~~~
> typeof true; // boolean
> typeof null; //object
> ~~~

또한 객체의 속성에 관해서는 객체의 속성이 갖고있는 타입의 값을 반환한다. 함수에 관해서는 `object` 대신 `function` 을 반환한다. 

## 관계 연산자
관계 연산자는 피연산자들을 비교하고 **비교의 참 여부에 따라 부울 값을 반환**한다. 관계 연산자에는 `in` 과 `instanceof` 가 있다. <br>

`in` 연산자는 생각보다 정말 쉽다. 객체 안에 특정한 속성이 있는 경우에 `true`를 반환하고, 그렇지 않은 경우에는 `false`를 반환하는 연산자이다. 아래는 간단한 예시이다.

> ~~~
> let arr=[10, 20, 77, 40];
> 4 in arr; //false
> 2 in arr; //true
> ~~~

`instanceof` 연산자는 명시된 객체가 명시된 객체형인 경우 true를 반환한다. 주로 예외 처리를 할 때 사용된다. 

## this
JS에서 this는 **가장 가까운 객체**를 나열하는 키워드이다. 여기서 말하는 가장 가까운 객체는 **함수의 현재 실행 컨텍스트**를 말한다. 아래는 콘솔창을 켰을 때 this를 치면 나타나는 예시이다.

> ~~~
> this // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
> ~~~

기본적으로 this는 **전역 객체를 참조**한다. **메소드 내부의 this는 메소드를 호출한 부모 객체를 참조**하며, **생성자 함수 코드 내부의 this는 새로 생성된 객체를 참조**한다. 

## 확산 연산자
확산 연산자는 스프레드 연산자로 불리기도 한다. 여기서 스프레드는 흩뿌리다, 퍼지다 등의 뜻을 가진다. 그렇다면 스프레드 연산자, 즉 확산 연산자는 무엇일까? <br>
쉽게 생각하면 스프레드 연산자는 배열의 요소를 흩뿌리는 연산자이다. 배열 뿐만아니라 매개 변수에서도 활용이 가능하다.

> ~~~
> let arr = [5, 8, 9, 10];
> console.log(...arr) // 5 8 9 10
> ~~~

위의 코드는 쉽게 확인할 수 있듯 `...arr`라는 코드가 배열 `arr`의 안쪽 값을 반환해주는 코드인 걸 알 수 있다. 또한 `[...arr]` 를 하고 확산 연산자를 사용하면 `arr`이라는 배열과 값이 같은 배열을 만들어낸다.